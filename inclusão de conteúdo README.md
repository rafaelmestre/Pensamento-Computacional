# ETAPA 1 - MICROFUNDAMENTO **PENSAMENTO COMPUTACIONAL**

[üîô HOME](https://www.notion.so/EIXO-1-39857bb82a724cf3b550d48d98e1d8f5?pvs=21) 

## [UNIDADE](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21) 1Ô∏è‚É£

### TEMA 1: Pensamento computacional - Conceito e import√¢ncia

- [x]  O que √© pensamento computacional
- [x]  Import√¢ncia do pensamento computacional

### TEMA 2: Os pilares do pensamento computacional

- [x]  [Vis√£o Geral](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)
- [x]  [Decomposi√ß√£o](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)
- [x]  [Reconhecimento de padr√µes](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)
- [x]  [Abstra√ß√£o](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)
- [x]  [Automa√ß√£o](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)

### TEMA 3: Outras estrat√©gias para resolver problemas

- [x]  [Paraleliza√ß√£o](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)
- [x]  [Simula√ß√£o](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)
- [x]  [Avalia√ß√£o de solu√ß√µes](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)

- [x]  [S√≠ntese](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)

## [UNIDADE](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21) 2Ô∏è‚É£

### TEMA 1: Computa√ß√£o desplugada: conceito e import√¢ncia

- [x]  [O que √© computa√ß√£o desplugada?](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)
- [x]  [Import√¢ncia da computa√ß√£o desplugada](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)

### TEMA 2: Resolu√ß√£o de problemas computacionais sem computador

- [x]  [Compress√£o de texto](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)
- [x]  [Adivinha√ß√£o de n√∫mero](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)
- [x]  [Roteiro tur√≠stico](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)
- [x]  [Nonograma](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)

- [x]  [S√≠ntese](https://www.notion.so/PENSAMENTO-COMPUTACIONAL-7ff537fe162c4b1ba3298045f21d4920?pvs=21)

---

## CADERNO

- o que √© pensamento computacional.
- o que √© pensamento algor√≠tmico.
- a import√¢ncia de se ter um pensamento organizado.

---

# UNIDADE 1

## TEMA 1: Conceito e Import√¢ncia

O processo do pensamento computacional para **resolu√ß√£o de problemas** se baseia em quatro pilares:

1. Decomposi√ß√£o: Quebrar o problema em problemas menores, mais gerenci√°veis. Ex. ao inv√©s de arrumar o quarto inteiro, podemos arrumar por partes‚Ä¶
2. Reconhecimento de padr√µes: Analisar e identificar similaridades entre partes diferentes. Ex. nem toda roupa vai em cabides e dentre as roupas que s√£o dobradas, nem todas s√£o dobradas da mesma forma.
3. Abstra√ß√£o: Identificar os detalhes mais importantes e desprezar os demais. Ex quando se pensamos em separar roupas sujas, n√£o damos import√¢ncia para o tipo de cada uma.
4. Automa√ß√£o, tamb√©m chamado por alguns de pensamento algor√≠tmico ou, simplesmente, algoritmo: Desenvolver um processo passo a passo para resolver o problema (por humanos ou computadores). Ex. 

[MATERIAL COMPLEMENTAR](http://sorayaroberta.com/guia.pdf) 

Podemos afirmar que os quatro pilares do pensamento computacional constituem uma sequ√™ncia de passos bem definidos para se resolver um problema. **FALSO**: **pois n√£o h√° ordem pr√©-definida para se utilizar cada um dos pilares do pensamento computacional.**

---

## TEMA 2: Os pilares do pensamento computacional

### DECOMPOSI√á√ÉO

Decomposi√ß√£o √© um dos quatro pilares do Pensamento Computacional. Esse processo contribui para tornar vi√°vel uma solu√ß√£o para um problema complexo, a partir da proposta de reduzir um problema em subproblemas menores. Pensar em uma parte do problema de cada vez √© mais f√°cil do que pensar no problema completo.

Em particular, quando as partes do problema s√£o semelhantes, podemos utilizar um modelo de algoritmo muito comum: o ‚Äúdivis√£o e conquista‚Äù. Esse modelo tem esse nome, porque se baseia na ideia de:

1. dividir o problema em partes menores do mesmo problema,
2. conquistar ou resolver essas partes menores,
3. combinar as solu√ß√µes das partes menores para obter uma solu√ß√£o para o problema original.

```mermaid
graph TD
    A["Dividir"] --> B["Conquistar"]
    B --> C["Combinar"]
```

```mermaid
graph TD
    A[Problema] --> B[Subproblema 1]
    A --> C[Subproblema 2]
    B --> D[Solu√ß√£o para o subproblema 1]
    C --> E[Solu√ß√£o para o subproblema 2]
    D --> F[Solu√ß√£o para o problema]
    E --> F
```

MATERIAL COMPLEMENTAR

[Quicksort](https://pt.wikipedia.org/wiki/Quicksort)

---

### RECONHECIMENTO DE PADR√ïES

O **reconhecimento de padr√µes** √© um dos pilares do Pensamento Computacional e consiste na busca por similaridades compartilhadas entre problemas ou por partes de um problema.

Todos n√≥s reconhecemos padr√µes no nosso cotidiano, por exemplo, quando olhamos para o c√©u e, pelas nuvens, percebemos que uma tempestade se aproxima. Os profissionais da √°rea de computa√ß√£o tamb√©m aplicam o reconhecimento de padr√µes, tanto para aproveitar solu√ß√µes j√° existentes quanto para simplificar um problema ou desenvolver solu√ß√µes que possam ser mais facilmente reutilizadas.

---

### ABSTRA√á√ÉO

Como representar o mundo real para o computador? Isso √© muito complexo.

Em nossas atividades do cotidiano, n√≥s reduzimos a complexidade, desprezando v√°rios detalhes. Por exemplo, em um local sem sinal de celular, se formos passar um roteiro para algu√©m chegar em um determinado endere√ßo, n√£o falamos coisas do tipo: ‚Äúvai passar uma casa branca de janelas de madeira, depois outra casa branca com port√£o preto, depois uma casa azul, depois outra casa branca com grande marrom...‚Äù. Mas simplificamos informa√ß√µes e falamos algo do tipo: ‚Äúsiga at√© o posto de gasolina‚Äù, ou ‚Äúvire a terceira √† direita‚Äù.

**Ent√£o, nosso problema inicial se torna o seguinte:**¬†Como gerar uma vis√£o mais simplificada de um problema, para que se torne mais f√°cil solucion√°-lo?

**A abstra√ß√£o consiste exatamente nesse processo de sele√ß√£o dos elementos essenciais de determinado problema, ignorando detalhes irrelevantes para o contexto em quest√£o. Dessa forma, o problema fica mais f√°cil de ser compreendido e a solu√ß√£o computacional se torna mais vi√°vel.**

---

### AUTOMA√á√ÉO (ALGORITMOS)

Depois de aplicar os processos de decomposi√ß√£o, reconhecimento de padr√µes e abstra√ß√£o, estamos prontos para detalhar uma solu√ß√£o em forma de algoritmo, permitindo, assim, a automa√ß√£o do processo por uma pessoa ou m√°quina.

Observem que algoritmos podem ser √∫teis tamb√©m para pessoas, pois representam uma organiza√ß√£o do pensamento em etapas ou atividades bem definidas.

Entretanto, quando o alvo for um computador, o cuidado com a clareza e precis√£o dos algoritmos deve ser ainda maior, pois, ao contr√°rio de um ser humano, um computador n√£o tem bom senso ou criatividade para complementar detalhes n√£o especificados.

**Algoritmos s√£o como uma receita de bolo, existe uma ordem certa a ser executada, e com os detalhes de cada ingrediente, que traduzindo para linguagem computacional seria os dados. Da mesma forma que se faz uma receita em sua individualidade, tamb√©m √© poss√≠vel desenvolver diferentes tarefas ao mesmo tempo e no final ter um almo√ßo com diferentes receitas executadas. Algoritmos s√£o ponto de partida para um programa de computador.** 

**Para que os algoritmos s√£o usados?**

R. Para testar uma solu√ß√£o para um problema.

Incorreta. Um algoritmo n√£o √© uma ferramenta de teste. Um algoritmo √© um conjunto de instru√ß√µes passo a passo para resolver um problema.

**R. Para detalhar a solu√ß√£o para um problema.**

---

## TEMA 3: Outras estrat√©gias para resolver problemas

### **PARALELIZA√á√ÉO**

O paralelismo ocorre sempre que **mais de uma atividade √© executada simultaneamente.** Ele pode se basear em um dos dois tipos b√°sicos de particionamentos:

- Particionamento de dados e
- Particionamento de tarefas

No particionamento de dados, uma grande quantidade de dados √© dividida em partes menores que podem ser manipuladas em paralelo. Ap√≥s os dados serem processados, eles s√£o combinados novamente em um √∫nico conjunto.

No particionamento de tarefas, tarefas independentes s√£o distribu√≠das para serem executadas simultaneamente.

Pode-se tamb√©m combinar os dois tipos de particionamentos em uma mesma solu√ß√£o.

A tend√™ncia atual √© que o paralelismo esteja cada vez mais presente em solu√ß√µes computacionais.

---

### SIMULA√á√ÉO

A simula√ß√£o √© mais uma estrat√©gia para resolu√ß√£o de problemas. Ela √© uma simplifica√ß√£o do mundo real, que pode ser √∫til para melhorar a compreens√£o de um conceito ou para testar solu√ß√µes, de uma forma mais barata, f√°cil e sem riscos.

√Äs vezes, uma simula√ß√£o √© desenvolvida por meio de programa√ß√£o convencional, mas pode tamb√©m ser baseada no uso de ferramentas que auxiliam na cria√ß√£o de uma simula√ß√£o. √â um processo que exige muito cuidado para que seus resultados sejam significativos. Por isso, n√£o √© f√°cil desenvolver um modelo para simula√ß√£o.

- Formula√ß√£o do problema;
- Planejamento do projeto;
- Projeto da simula√ß√£o; cria√ß√£o de um fluxograma de como o sistema ser√° desenvolvido facilita a compreens√£o de quais vari√°veis est√£o envolvidas e como elas se interagem;
- Implementa√ß√£o do modelo;
- Valida√ß√£o e verifica√ß√£o;
- Documenta√ß√£o: analise dos resultados.

Para reconhecer se a simula√ß√£o √© a abordagem correta para resolver um problema espec√≠fico, quatro itens devem ser avaliados:

1 - Tipo de problema;

2 - Disponibilidade e recursos;

3 - Custos;

4 - Disponibilidade de dados.

Apenas problemas complexos utilizam simulados, porque os simples n√£o precisam disso. 

> Simula√ß√£o est√° relacionada ao processo de abstra√ß√£o.
> 

---

### AVALIA√á√ÉO DE SOLU√á√ïES

Os quatro pilares do Pensamento Computacional n√£o garantem que uma solu√ß√£o esteja correta e eficiente. Para isso, √© necess√°rio avaliar a proposta de solu√ß√£o.

Uma abordagem prudente √© presumir que um algoritmo est√° incorreto at√© que seja mostrado como correto. Em geral, mostra-se que um algoritmo est√° correto por meio da realiza√ß√£o de uma s√©rie de testes, que confirmam que os resultados gerados s√£o os esperados.

Considerando a efici√™ncia, devemos nos lembrar que podem haver algoritmos diversos para resolver um mesmo problema, tendo cada um deles um desempenho diferente. Por exemplo, um algoritmo pode gerar resultados corretos, mas pode repetir algumas etapas desnecessariamente, tornando a solu√ß√£o ineficiente. Para medir a efici√™ncia de um algoritmo de uma forma confi√°vel e que possa ser comparada com a de outros algoritmos pode-se utilizar a fun√ß√£o de complexidade de um algoritmo. Assim, julga-se a efici√™ncia de um algoritmo analisando o comportamento de sua fun√ß√£o de complexidade.

A avalia√ß√£o de uma solu√ß√£o computacional √© fundamental para evitar consequ√™ncias negativas ou preju√≠zos enormes.

### S√çNTESE

```mermaid
graph TD
    PC[Pensamento Computacional] --> CI
    PC --> ERP
    CI[Conceito e Import√¢ncia]
    ERP[Estrat√©gias para Resolu√ß√£o de Problemas]
    D[Decomposi√ß√£o]
    A[Abstra√ß√£o]
    RP[Reconhecimento de padr√µes]
    AU[Automa√ß√£o]
    PEC[Pensamento Computacional]
    CEI[Conceito e Objetivo / Exemplo de Aplica√ß√£o / Import√¢ncia]
      
    ERP --> D --> PEC
    ERP --> A --> PEC
    ERP --> RP --> PEC
    ERP --> AU --> PEC --> CEI
    ERP --> P[Paraleliza√ß√£o] --> CEI
    ERP --> S[Simula√ß√£o] --> CEI
    ERP --> AV[Avalia√ß√£o] --> CEI
    
```

---

## UNIDADE 2

## TEMA 1: COMPUTA√á√ÉO DESPLUGADA: CONCEITO E IMPORT√ÇNCIA

### **O QUE √â COMPUTA√á√ÉO DESPLUGADA**

A computa√ß√£o desplugada tem como proposta o ensino de conceitos de computa√ß√£o sem o uso de computadores. **O objetivo n√£o √© entender o funcionamento de um computador,** mas a resolu√ß√£o de problemas que lidam com conceitos diversos da Ci√™ncia da Computa√ß√£o, tal como compress√£o de dados, avalia√ß√£o de interface e algoritmos de classifica√ß√£o e busca.

Dez princ√≠pios fundamentam a computa√ß√£o desplugada, dentre eles, o foco em conceitos de computa√ß√£o, em vez de programa√ß√£o, e o est√≠mulo para que os participantes descubram as respostas por si mesmos.

**Princ√≠pios que fundamentam a conex√£o desplugada:**

**1 - N√£o depender do uso de computadores;**

**2 - N√£o foca na programa√ß√£o** (conceito de computa√ß√£o)**;**

**3 - Tornar as atividades cenest√©sicas** (que envolvam f√≠sico e movimentos)**;**

**4 - Envolver atividades divertidas;**

**5 - Usar materiais de baixo custo;**

**6 - Liberar material para uso por outros;**

**7 - Ser independente de G√™nero;**

**8 - Utilizar hist√≥ria para captar interesse;**

**9 - Estimular autonomia;**

**10 - Adequar-se a pequenos erros dos participantes.**

**Qual o objetivo da computa√ß√£o desplugada?**

**R. Auxiliar na compreens√£o de conceitos de computa√ß√£o sem o uso de computadores.**

---

### **IMORT√ÇNCIA DA COMPUTA√á√ÉO DESPLUGADA**

A computa√ß√£o desplugada oferece diversos benef√≠cios para a sociedade. Dentre eles, ela auxilia a desenvolver conceitos de computa√ß√£o e o racioc√≠nio l√≥gico para resolver problemas propostos. E isso √© v√°lido inclusive para estudantes de cursos da √°rea de computa√ß√£o.

Podemos afirmar que todas as op√ß√µes abaixo apresentam contribui√ß√µes da computa√ß√£o desplugada,¬†**EXCETO**:

- Aprendizado de conceitos de computa√ß√£o.
- Inclus√£o de pessoas que n√£o t√™m acesso f√°cil a tecnologias.
- Desenvolvimento de habilidades de racioc√≠nio.
- **Economia de energia.**

---

### COMPRESS√ÉO DE TEXTO

Apenas utilizando l√°pis e papel podemos discutir uma solu√ß√£o para um problema de compress√£o de texto. 

1 - Percorrer o texto para gerar um vocabul√°rio contendo as sequ√™ncias de caracteres que se repetem, incluindo a frequ√™ncia de cada sequ√™ncia;

2 - Ordenar o vocabul√°rio, da sequ√™ncia com maior frequ√™ncia para a menor;

3 - Gerar um c√≥digo para cada sequ√™ncia;

4 - Percorrer o texto novamente , substituindo as sequ√™ncias de caracteres por seus c√≥digos.

**Para realizar uma compress√£o de texto, qual a primeira atividade a realizar?**

**Contar as sequ√™ncias de caracteres que se repetem.**

---

### ADIVINHA√á√ÉO DE N√öMERO

Uma estrat√©gia interessante para resolver problemas √© tentar reduzi-lo para que seja mais vi√°vel chegar a uma solu√ß√£o. 

Dividindo o total pela metade questionado se √© maior ou menor o valor mediano (central) e assim sucessivamente at√© localizar o numero desejado.

---

### ROTEIRO TUR√çSTICO

Apenas utilizando l√°pis e papel podemos discutir uma solu√ß√£o para um problema de defini√ß√£o de Roteiro Tur√≠stico, baseada no uso de **grafos**. Um grafo possui n√≥s, ou pontos, e arestas que s√£o linhas que unem esses n√≥s. No nosso caso, os n√≥s indicariam os pontos tur√≠sticos e as arestas, os caminhos entre esses pontos.

Este tipo de problema segue o padr√£o do Problema do Caixeiro Viajante (PCV), no qual se busca a rota com menor custo para percorrer uma s√©rie de cidades, sem repetir nenhuma, retornando √† cidade de origem. H√° diversos algoritmos existentes para resolver esse problema, que poderiam ser adotados para resolver o nosso problema espec√≠fico.

Para solu√ß√£o do problema de definir um roteiro tur√≠stico, aplicamos o reconhecimento de padr√µes. Est√° senten√ßa √© falsa ou verdadeira?

**Verdadeira, porque identificamos que o problema se assemelha ao do Caixeiro Viajante e, assim, podemos aplicar algoritmo j√° conhecido para resolv√™-lo.**

---

### **NONOGRAMA**

Apenas utilizando l√°pis e papel discutiremos uma solu√ß√£o para um quebra-cabe√ßa japon√™s, denominado Nonograma. Esse problema ressalta a import√¢ncia do reconhecimento de padr√µes para sua resolu√ß√£o e permite perceber a import√¢ncia de se conhecer bem o contexto de um problema, pelo exerc√≠cio cont√≠nuo, algo que se aplica em qualquer √°rea do conhecimento. 

**Exerc√≠cio para racioc√≠nio l√≥gico.** 

---

### SINTESE

```mermaid
graph TD
CD[Computa√ß√£o Desplugada]
CI[Conceito e Import√¢ncia]
ERP[Exemplos de Resolu√ß√£o de Problemas]
CT[COMPRESS√ÉO DE TEXTO]
AN[ADVINHA√á√ÉO DE N√öMERO]
RT[ROTEIRO TUR√çSTICO]
NN[NONOGRAMA]

CD --> CI
CD --> ERP --> CT --> CO[Codifica√ß√£o]
ERP --> AN --> AD[√Årvore de decis√£o]
AD --> EA[Efici√™ncia de Algor√≠timos]
ERP --> RT --> AB[Abtra√ß√£o]
RT --> RP[Reconhecimento de Padr√µes]
ERP --> NN
NN --> REP[Reconhecimento de Padr√µes]
NN --> IP[Import√¢ncia da Pratica]
```
